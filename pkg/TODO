### For next release ###########################################################

## Important


- MH: in dnvmix.Rd, the description of (...) (the ellipsis argument) looks odd - is 		that intended?
- Write vignette nvmix_functionality.Rmd
	EH: I'm on it :)

- EH: References in the manuals/vignette? Maybe the three publications of Genz and Bretz as well as the "normal people"?

## To be discussed:

- EH: incorporate the case of a singular scale matrix
      (or at least give better error message)

	EH: pnvmix(), rnvmix() and dnvmix() now return an error if the cholesky 		composition via chol(...) fails (I used tryCatch to have a nicer error).
	I noticed that dnvmix() is supposed to return Inf if x = loc and scale does not 	have full rank. dnvmix() never did that because the execution was stopped when 		scale was not positive definite. It still stops (I put tryCatch also in 		factorize()). If the matrix doesn't have full rank, the density just does not 		exist and I think returning Inf/... is misleading - thoughts?
- EH: Does it make sense to choose the default of fun.eval[2] differently?
      I feel it should be something like 1/abstol, so that if one plays
      with abstol, one has a reasonable chance not having to modify
      fun.eval[2]. I realized this when choosing abstol = 1e-8 (then
      with fun.eval[2] = 1e8, the computations took forever.

	EH: the default is set such that the algorithm terminates with reasonable 		tolerances (0.001, 0.0005, maybe 0.0001). Tolerances beyond that will take 		forever one way or another. 
- EH/MH: 'rnvmix()' needs a 'method' argument (see 'pnvmix') + new argument 	'mix' ('rmix'?)
         for passing a RNG
         => call other arguments 'mix' 'qmix' instead (check carefully)

	EH: DONE for rnvmix(), has a few more arguments now. (rmix, qmix, method, skip)
	Should 'mix' in 'pnvmix' and 'dmvmix' be called 'qmix' instead? For consistency?


- DONE  EH: rnvmix() should have 'skip' if method = 'sobol' 
- DONE  EH: renaming etc in dnvmix() similar to pnvmix()
- DONE	EH: TODOs inside pnvmix()
- DONE 	EH: pnvmix() has multiple lower/upper as input, but only one scale. pnvmix1() 		then calculates t(chol(scale)) for each input => maybe do that in pnvmix once and 	pass it as argument to pnvmix1()
- DONE ?pnvmix and ?dnvmix describe the output value 'numiter'. Can you had
      	(on each help pages) half a sentence what these iterations are exactly?
      	=> alternatively, shouldn't we rather return the variance? (one of the
         five components you previously returned) Seems more intuitive, no?
	EH: Will do. variance can be computed from error; numiter (or equivalently, total 	function evaluations) should just give an idea of how long it took to converge
- DONE	EH: ?pnvmix describes 'precond'; can you add half a sentence
  	describing the idea behind the preconditioning, please?



### TODO #######################################################################

- TODO Allow rmix() to be specified in pnvmix() for method = 'PRNG'. This can be a first 
	Step towards evaluation GIG mixtures, where qmix() is not available but one can 	sample from the mixing distribution. 
- TODO look into quantile functions of univariate (marginal) normal variance mixtures.
       If we have a function, say, qnvmix1 (for 1 dimensional normal variance mixtures),
       we have a way to sample from univariate normal variance mixtures using inversion,
       which can then be used for quasi-Monte Carlo sampling
- TODO Need fitnvmix(): check what other packages do
- DONE implement dnvmix() as well as wrappers for normal/t case.
- DONE (d=1): pnvmix() should work with d = 1 and with missing data
- DONE pStudent should work with df = Inf
- DONE implement multivariate normal distribution
- DONE rename 'a' and 'b' to 'lower' and 'upper'; 'nu' to 'df'
       (first arg should be 'upper' with default lower being '-Inf,...')
- DONE 'R' should be 'scale' and we need a 'standardized = FALSE' argument;
       if standardized = TRUE, loc = 0 and sigma = correlation matrix is assumed
       ... or so)
- DONE 'swap' needs to be improved
- DONE 'func' not needed if 'base case' in pnvmix() is part of the loop
       (only one call necessary then, so can be omitted)
- DONE more intuitive names for arguments concerning tolerance(s)
- DONE polish ./src


### More thoughts ##############################################################

pnvmix() does not work for multiple upper/lower input vectors, since the
preconditioning heavily depends on the input parameters. However, in d = 1,
since we have the function pnorm(), the integration problem is actually
one-dimensional. In this case, no reordering needs to be done and we can implement
a "vectorized" pnvmix1() (I use 1 to highlight that it works only for d = 1).
Indeed, we only need to sample from the mixture distribution and then evaluate
pnorm() with different upper/lower bounds. We can use common random numbers
(i.e. simulate from R, use these simulations for all upper/lower) and evaluate
the df efficiently at many points. This is particularly useful for
implementing qnvmix1(), since pnvmix1() can evaluate at multiple "upper" at once.
Still, pnvmix1() will only approximate the true df, numerically inverting that
approximated df will inevitably lead to numerical inaccuracies.


### Packages dealing with multivariate Student's t distribution ################

2018-06-21:
- monomvn (estimation under monotone pattern missing data; MLE & Bayesian)
- mvnfast (no pnvmix(), simulation, density, Mahalanobis distances)
- tmvtnorm (has ptmvt(), based on Gibbs sampler; see http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.26.6892)
- MVT (studentFit(); for fixed nu (= eta here), estimates location and scale; paper mentions EM Algorithm)
- mvtnorm (clear; no fitting, no non-integer dof, qmvt() [equicoordinate quantile function])
- QRM (fit.mst())
