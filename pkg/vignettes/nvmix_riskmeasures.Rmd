---
title: Estimating risk measures for normal variance mixture distributions
author: Erik Hintz, Marius Hofert and Christiane Lemieux
date: '`r Sys.Date()`'
output:
  html_vignette:
    css: style.css
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Estimating risk measures for normal variance mixture distributions}
  %\VignetteEncoding{UTF-8}
---



\newcommand*{\IR}{\mathbb{R}}
\newcommand*{\NVM}{\operatorname{NVM}}
\newcommand*{\IG}{\operatorname{IG}}
\newcommand*{\N}{\operatorname{N}}
\renewcommand*{\P}{\mathbb{P}}
\newcommand*{\E}{\mathbb{E}}
\newcommand*{\VaR}{\operatorname{VaR}}
\newcommand*{\ES}{\operatorname{ES}}
\newcommand*{\ba}{\mathbf{a}}
\newcommand*{\bZ}{\mathbf{Z}}
\newcommand*{\bX}{\mathbf{X}}
\newcommand*{\bmu}{\mathbf{\mu}}


```{r setup, message = FALSE}
library(nvmix)
library(RColorBrewer)
doPDF <- FALSE
```

## Introduction

A random vector $\bX=(X_1,\dots,X_d)$ follows a *normal
variance mixture*, in notation $\bX\sim \NVM_d(\bmu,\Sigma,F_W)$, if, in
distribution,
$$
\bX = \bmu+\sqrt{W}A\bZ, 
$$
where $\bmu\in\IR^d$ denotes the *location (vector)*,
$\Sigma=AA^\top$ for $A\in\IR^{d\times k}$ denotes the *scale (matrix)* (a
covariance matrix), and the mixture variable $W\sim F_W$ is a non-negative random
variable independent of $\bZ\sim\N_k(\mathbf{0},I_k)$ (where
$I_k\in\IR^{k\times k}$ denotes the identity matrix).
Both the
Student's $t$ distribution with degrees of freedom parameter
$\nu>0$ and the normal distribution are normal variance mixtures;
in the former case, $W\sim\IG(\nu/2, \nu/2)$ (inverse gamma) and in the latter
case $W$ is almost surely constant (taken as $1$ so that $\Sigma$ is the
covariance matrix of $\bX$ in this case).

It follows readily from the stochastic representation that linear combinations
of multivariate normal variance mixtures are univariate normal variance mixtures.
Let $\ba\in\mathbb{R}^d$. If $\bX\sim \NVM_d(\bmu,
\Sigma,F_W)$, then $\ba^\top \bX \sim \NVM_1(\ba^\top\bmu,
\ba^\top\Sigma\ba,F_W)$. 

If $\bX$ models, for instance,
financial losses, $\ba^\top \bX$ is the loss of a portfolio with 
portfolio weights $\ba$. It is then a common task in risk management
to estimate risk measures of the loss $\ba^\top \bX$. We consider
the two prominent risk measures value-at-risk and expected shortfall. 

## Estimating Risk Measures for $X\sim NVM_1(\mu, \sigma, F_W)$

In the following, assume without loss of generality that $X\sim \NVM_1(0, 1, F_W)$, 
the general case follows from a location-scale argument.

### Value-at-risk

The *value-at-risk* of $X$ at confidence level $\alpha\in(0,1)$ is merely 
the $\alpha$-quantile of $X$. That is,
$$ \VaR_\alpha(X) = \inf\{x\in[0,\infty):F_X(x)\ge \alpha\},$$
where $F_X(x)=\P(X\le x)$ for $x\in\mathbb{R}$ is the distribution function of 
$X$. Such quantile can be estimated via the function `qnvmix()`, or equivalently,
via the function `VaRnvmix()` of the `R` package `nvmix`. 

As an example, consider $W\sim\IG(\nu/2, \nu/2)$ so that $X$ follows a $t$
distribution with $\nu$ degrees of freedom. In this case, the quantile is known.
If the argument `qmix` is provided as a string, `VaRnvmix()` calls `qt()`;
if `qmix` is provided as a function or list, the quantile is internally estimated
via a Newton algorithm where the univariate distribution function $F_X()$ is
estimated via randomized quasi-Monte Carlo methods. 

```{r, fig.align = "center", fig.width = 7, fig.height = 7, fig.show = "hold"}
set.seed(1) # for reproducibility
qmix  <- function(u, df) 1/qgamma(1-u, shape = df/2, rate = df/2)
df    <- 3.5 
n     <- 20
alpha <- seq(from = 0.9, to = 0.995, length.out = n)
VaR_true <- VaRnvmix(alpha, qmix = "inverse.gamma", df = df)
VaR_est  <- VaRnvmix(alpha, qmix = qmix, df = df)
stopifnot(all.equal(VaR_true, qt(alpha, df = df)))
## Prepare plot
pal <- colorRampPalette(c("#000000", brewer.pal(8, name = "Dark2")[c(7, 3, 5)]))
cols <- pal(2) # colors
if(doPDF) pdf(file = (file <- "fig_VaRnvmix_comparison.pdf"),
              width = 7, height = 7)
plot(NA, xlim = range(alpha), ylim = range(VaR_true, VaR_est), 
     xlab = expression(alpha), ylab = expression(VaR[alpha]))
lines(alpha, VaR_true, col = cols[1], lty = 2, type = 'b')
lines(alpha, VaR_est,  col = cols[2], lty = 3, lwd = 2)
legend('topleft', c("True VaR", "Estimated VaR"), col = cols, lty = c(2,3),
       pch = c(1, NA))
if(doPDF) dev.off()
```

### Expected Shortfall

Another risk measure of great theoretical and practical importance is the
*expected-shortfall*. The expected shortfall of $X$ at confidence level 
$\alpha\in(0,1)$ is, provided the integral converges, given by
$$ \ES_\alpha(X) = \frac{1}{1-\alpha} \int_\alpha^1 \VaR_u(X)du.$$
If $F_X()$ is continuous, one can show that
$$ \ES_\alpha(X) = \E(X \mid X > \VaR_\alpha(X)).$$

The function `ESnvmix()` in the `R` package `nvmix` can be used to estimate
the expected shortfall for univariate normal variance mixtures. Since these
distributions are continuous, we get the following:

$$
(1-\alpha) \ES_\alpha(X) = \E\left(X \mathbf{1}_{\{X>\VaR_\alpha(X)\}}\right)= 
\E\left( \sqrt{W} Z \mathbf{1}_{\{\sqrt{W} Z > \VaR_\alpha\}}\right)= 
\E\Big( \sqrt{W} \E\big(Z \mathbf{1}_{\{Z> \VaR_\alpha(X)/\sqrt{W}\}} \mid W\big)\Big)= 
\E\left(\sqrt{W} \phi(\VaR_\alpha(X) / \sqrt{W})\right)
$$
Here, $\phi(x)$ denotes the density of a standard normal distribution and we used 
that $\int_k^\infty x\phi(x)dx = \phi(k)$ for any $k\in\IR$. Internally, the 
function `ESnvmix()` estimates $\ES_\alpha(X)$ via a randomized quasi-Monte
Carlo method by exploiting the displayed identity. 

In case of the normal and $t$ distribution, a closed formula for the 
expected shortfall is known; this formula is then used by `ESnvmix()` if 
`qmix` is provided as string. 

```{r, fig.align = "center", fig.width = 7, fig.height = 7, fig.show = "hold"}
ES_true <- ESnvmix(alpha, qmix = "inverse.gamma", df = df)
ES_est  <- ESnvmix(alpha, qmix = qmix, df = df)
## Prepare plot
if(doPDF) pdf(file = (file <- "fig_ESnvmix_comparison.pdf"),
              width = 7, height = 7)
plot(NA, xlim = range(alpha), ylim = range(ES_true, ES_est), 
     xlab = expression(alpha), ylab = expression(ES[alpha]))
lines(alpha, ES_true, col = cols[1], lty = 2, type = 'b')
lines(alpha, ES_est,  col = cols[2], lty = 3, lwd = 2)
legend('topleft', c("True ES", "Estimated ES"), col = cols, lty = c(2,3),
       pch = c(1, NA))
if(doPDF) dev.off()
```