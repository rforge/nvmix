---
title: Fitting Multivariate Normal Variance Mixtures
author: Erik Hintz, Marius Hofert and Christiane Lemieux
date: '`r Sys.Date()`'
output:
  html_vignette:
    css: style.css
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Fitting Multivariate Normal Variance Mixtures}
  %\VignetteEncoding{UTF-8}
---
```{r, message = FALSE, warning = FALSE}
library(nvmix)
library(qrmdata) # for the dataset
library(QRM) # for returns()
library(xts) # for plotting time-series objects 
doPDF <- FALSE
run   <- FALSE # run slow parts
```

## 1 Introduction

In this vignette it shall be demonstrated how the package `nvmix` can be used
to fit multivariate normal variance mixtures to a real dataset.
We consider stock return data from constitutents of the DowJones30 index;
the data are obtained from the package `qrmdata`. After cleaning, the daily
returns of the 30 stocks look as follows:

```{r, fig.align = "center", fig.width = 7, fig.height = 12, fig.show = "hold"}
data("DJ_const") # load data
DJ30.X.d <- returns(DJ_const) # obtain daily returns
DJ30.X.d <- DJ30.X.d[-which(rowSums(is.na(DJ30.X.d))>0),] # remove rows with >=1 NA
if(doPDF) pdf(file = (file <- "fig_dailyreturnsDJ30.pdf"),
              width = 7, height = 12)
plot.zoo(DJ30.X.d) # plot
if(doPDF) dev.off()
```

Recall that a random vector $\mathbf{X}=(X_1,\dots,X_d)$ follows a *normal
variance mixture*, in notation $\mathbf{X}\sim NVM_d(\mathbf{\mu},\Sigma,F_W)$, 
if, in distribution,
\begin{align*}
  \mathbf{X}=\mathbf{\mu}+\sqrt{W}A\mathbf{Z},
\end{align*}
where $\mathbf{\mu}\in\mathbb{R}^d$ denotes the *location (vector)*,
$\Sigma=AA^\top$ for $A\in\mathbb{R}^{d\times k}$ denotes the *scale (matrix)* (a
covariance matrix), and the mixture variable $W\sim F_W$ is a non-negative random
variable independent of $\mathbf{Z}\sim N_k(\mathbf{0},I_k)$ (where
$I_k\in\mathbb{R}^{k\times k}$ denotes the identity matrix). For the remainder
of this document we set $k=d$. We consider three choices for $W$:

- $W=1$ almost surely so that $\mathbf{X}$ follows a multivariate normal distribution with mean $\mathbf{\mu}$ and covariance matrix $\Sigma$;
- $W$ follows an inverse gamma distribution with shape and rate parameter set to
  $\nu/2$ for some $\nu>0$ in which case $\mathbf{X}$ follows a multivariate 
  $t$ distribution with $\nu$ degrees of freedom;
- $W$ follows a Pareto distribution with scale 1 and shape $\alpha>0$.

For each of those distributions we use the function `fitnvmix` to fit daily,
weekly and monthly return data and then perform a graphical goodness-of-fit test.
We remark that the first case is trivial (the maximum likelihood estimators for
$\mathbf{\mu}$ and $\Sigma$ are the sample mean and the sample variance, 
respectively) but included for the sake of comparison.


## 2 Fitting multivariate normal variance mixtures

### Parameter estimation

The function `fitnvmix()` can be used to fit any multivariate normal variance
mixture distribution to data so long as the quantile function of the mixing
variable $W$ is available. 
The specification of $W$ is passed to `fitnvmix()` via the argument `qmix`, 
see also the documentation for further details. For the three afforementioned 
special cases when $W$ is either constant, inverse gamma or pareto distributed,
the mixing distribution can be specified as character string in which case
analytical formulas for densities and weights are used. 

```{r}
set.seed(271) # for reproducibilty; 'fitnvmix' depends slighlty on .Random.seed
verbose <- 1 # suppress tracing from `fitnvmix` and only print warnings
## Construct dataset of weekly and monthly returns:
DJ30.X.w <- apply.weekly(DJ30.X.d,  FUN = colSums) # weekly returns
DJ30.X.m <- apply.monthly(DJ30.X.d, FUN = colSums) # monthly returns
## Case 1: W = constant
qmix1 <- "constant"
const.mix.fit.d <- fitnvmix(DJ30.X.d, qmix = qmix1, verbose = verbose)
const.mix.fit.w <- fitnvmix(DJ30.X.w, qmix = qmix1, verbose = verbose)
const.mix.fit.m <- fitnvmix(DJ30.X.m, qmix = qmix1, verbose = verbose)
## Case 2: W ~ inverse-gamma(nu/2, nu/2)
qmix2             <- "inverse.gamma"
mix.param.bounds2 <- c(0.5, 12) # dof-parameter between 0.5 and 12
invgam.fit.d <- fitnvmix(DJ30.X.d, qmix = qmix2, 
                         mix.param.bounds = mix.param.bounds2, verbose = verbose)
invgam.fit.w <- fitnvmix(DJ30.X.w, qmix = qmix2,
                         mix.param.bounds = mix.param.bounds2, verbose = verbose)
invgam.fit.m <- fitnvmix(DJ30.X.m, qmix = qmix2,
                         mix.param.bounds = mix.param.bounds2, verbose = verbose)
## Case 3: W ~ Par(1, nu)
qmix3             <- "pareto"
mix.param.bounds3 <- c(0.5, 12) # shape-parameter between 0.5 and 12
pareto.fit.d <- fitnvmix(DJ30.X.d, qmix = qmix3,
                         mix.param.bounds = mix.param.bounds3, verbose = verbose)
pareto.fit.w <- fitnvmix(DJ30.X.w, qmix = qmix3,
                         mix.param.bounds = mix.param.bounds3, verbose = verbose)
pareto.fit.m <- fitnvmix(DJ30.X.m, qmix = qmix3,
                         mix.param.bounds = mix.param.bounds3, verbose = verbose)
## Grab mixing parameters:
nu.ests.const     <- rep(NA, 3) # no mixing parameter
nu.ests.invgam    <- c(invgam.fit.d$nu, invgam.fit.w$nu, invgam.fit.m$nu)
nu.ests.pareto    <- c(pareto.fit.d$nu, pareto.fit.w$nu, pareto.fit.m$nu)
nu.ests           <- rbind(nu.ests.const, nu.ests.invgam, nu.ests.pareto)
rownames(nu.ests) <- c(qmix1, qmix2, qmix3)
colnames(nu.ests) <- c("daily", "weekly", "monthly")
print(nu.ests)
```

We can see that the estimates for `nu` (the parameter for the underlying mixing distribution)
is increasing in the length of the time interval over which the return was calculated;
this is in line with the intuition that for longer time periods, returns (as the some of daily returns)
converge to a normal distribution: In the multivariate $t$ case it is well known
that this distribution converges to a multivariate normal distribution as the
degree-of-freedom parameter $\nu\rightarrow\infty$. If $W$ follows a Pareto
distribution with scale 1 and shape $\nu$, it can be seen immediately from the
distribution function that $W\rightarrow 1$ in distribution (and thus in 
probability) as $\alpha\rightarrow\infty$ so that the resulting normal variance
mixture converges to a multivariate normal distribution.


The above calls to `fitnvmix()` were fast as analytical formulas for densities and
weights are known in these cases. In order to force `fitnvmix()` to approximate
densities and weights in these cases, we can pass the actual quantile function
in the argument `qmix`. We illustrate this using the monthly return data:

```{r}
if(run){
   ## Quantile function of inverse-gamma(nu/2, nu/2):
   qmix.invgam <- function(u, nu) 1 / qgamma(1 - u, shape = nu/2, rate = nu/2)
   ## Quantile function of Pareto(1, nu):
   qmix.pareto <- function(u, nu) (1-u)^(-1/nu)
   ## Call fitnvmix:
   invgam.fit.m2 <- fitnvmix(DJ30.X.m, qmix = qmix.invgam, 
                             mix.param.bounds = mix.param.bounds2, verbose = verbose)
   pareto.fit.m2 <- fitnvmix(DJ30.X.m, qmix = qmix.pareto, 
                             mix.param.bounds = mix.param.bounds3, verbose = verbose)
   ## Grab mixing parameters:
   nu.ests. <- matrix(c(invgam.fit.m2$nu, pareto.fit.m2$nu), nrow = 2)
   rownames(nu.ests.) <- c(qmix2, qmix3)
   colnames(nu.ests.) <- "monthly"
   print(nu.ests.)  
}
```

So the results coincide (up to numerical tolerances), but evidently, the latter is 
more time consuming as 
all log-densities and weights need to be approximated numerically in each 
iteration. 

### Visual goodness-of-fit

For elliptical distributions such as normal variance mixtures, it is convenient
to investigate the distribution of the mahalanbobis distance
$$ D^2(\mathbf{X}, \mathbf{\mu}, \Sigma^{-1}) = (\mathbf{X}-\mathbf{\mu})^\text{T}\Sigma^{-1}(\mathbf{X}-\mathbf{\mu})$$
Note that
$$ D^2(\mathbf{X}, \mathbf{\mu}, \Sigma^{-1}) \overset{\text{d}}{=} W \cdot \chi^2_d.$$
As a visual goodness-of-fit test we can plot the empirical quantiles $D^2(\mathbf{x_i}, \hat{\mathbf{\mu}}, \hat{\Sigma}^{-1})$
of the data $\mathbf{x}_1,\dots,\mathbf{x}_n$ versus their theoretical ones. Here,
$\hat{\mathbf{\mu}}$ and $\hat{\Sigma}$ denote the MLEs for $\mathbf{\mu}$ and
$\Sigma$ found by `fitnvmix()`. 

In the case of a multivariate normal and $t$ distribution, the distribution
of $D^2(\mathbf{X}, \mathbf{\mu}, \Sigma^{-1})$ is known and so are the 
theoretical quantiles:
If $W=1$ almost surely, $D^2(\mathbf{X}, \mathbf{\mu}, \Sigma^{-1})\sim \chi^2_d$;
if $W\sim\text{IG}(\nu/2, \nu,2)$ (the multivariate $t$ case) it follows that
$D^2(\mathbf{X}, \mathbf{\mu}, \Sigma^{-1})\sim F(d, \nu)$. 
In case of $W$ following a Pareto distribution, the quantiles need to be 
approximated numerically. This can be done using the function `qgammamix()` which
is in fact being used by the function `qqplot.maha()`. 

```{r, fig.align = "center", fig.width = 9, fig.height = 9, fig.show = "hold"}
if(run){
   if(doPDF) pdf(file = (file <- "fig_qqplots.maha.pdf"),
                 width = 9, height = 9)
   par(mfrow = c(3,3))
   qqplot.maha(as.matrix(DJ30.X.d), qmix = qmix1, loc = const.mix.fit.d$loc, 
               scale = const.mix.fit.d$scale)
   mtext("Daily, Normal")
   qqplot.maha(as.matrix(DJ30.X.w), qmix = qmix1, loc = const.mix.fit.w$loc, 
               scale = const.mix.fit.w$scale)
   mtext("Weekly, Normal")
   qqplot.maha(as.matrix(DJ30.X.m), qmix = qmix1, loc = const.mix.fit.m$loc, 
               scale = const.mix.fit.m$scale)
   mtext("Monthly, Normal")
   qqplot.maha(as.matrix(DJ30.X.d), qmix = qmix2, loc = invgam.fit.d$loc, 
               scale = invgam.fit.d$scale, df = invgam.fit.d$nu)
   mtext("Daily, MVT")
   qqplot.maha(as.matrix(DJ30.X.w), qmix = qmix2, loc = invgam.fit.w$loc, 
               scale = invgam.fit.w$scale, df = invgam.fit.w$nu)
   mtext("Weekly, MVT")
   qqplot.maha(as.matrix(DJ30.X.m), qmix = qmix2, loc = invgam.fit.m$loc, 
               scale = invgam.fit.m$scale, df = invgam.fit.m$nu)
   mtext("Monthly, MVT")
   qqplot.maha(as.matrix(DJ30.X.d), qmix = qmix3, loc = pareto.fit.d$loc, 
               scale = pareto.fit.d$scale, alpha = pareto.fit.d$nu)
   mtext("Daily, Pareto-mix")
   qqplot.maha(as.matrix(DJ30.X.w), qmix = qmix3, loc = pareto.fit.w$loc, 
               scale = pareto.fit.w$scale, alpha = pareto.fit.w$nu)
   mtext("Weekly, Pareto-mix")
   qqplot.maha(as.matrix(DJ30.X.m), qmix = qmix3, loc = pareto.fit.m$loc, 
               scale = pareto.fit.m$scale, alpha = pareto.fit.m$nu)
   mtext("Monthly, Pareto-mix")
   if(doPDF) dev.off()  
}
```

